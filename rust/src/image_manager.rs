use lazy_static::lazy_static;
use std::collections::HashMap;
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};
use std::ptr;
use std::slice;
use std::sync::{
    atomic::{AtomicU64, Ordering},
    Mutex,
};

// These types and functions are generated by bindgen from our C++ wrapper
use crate::bindings::{
    libraw_wrapper_create, libraw_wrapper_destroy, libraw_wrapper_get_metadata,
    libraw_wrapper_get_thumbnail, libraw_wrapper_open, LibRawHandle, LibRawMetadata,
};

// A wrapper struct to make the raw pointer `Send`-able.
// This is an `unsafe` declaration, but we are guaranteeing thread safety
// by ensuring that all access to the `HashMap` containing these pointers
// is protected by a `Mutex`.
struct SafeLibRawHandle(*mut LibRawHandle);
unsafe impl Send for SafeLibRawHandle {}

lazy_static! {
    // A thread-safe, global HashMap to store pointers to LibRaw instances.
    // The key is a unique u64 ID, and the value is the raw pointer.
    static ref IMAGE_MANAGER: Mutex<HashMap<u64, SafeLibRawHandle>> = Mutex::new(HashMap::new());
}

// A thread-safe, global atomic counter to generate unique IDs for each image.
static NEXT_IMAGE_ID: AtomicU64 = AtomicU64::new(1);

/// Loads a raw image file using LibRaw, stores the handle, and returns a unique ID.
pub fn load_raw(filepath: &str) -> Result<u64, String> {
    let c_filepath = CString::new(filepath).map_err(|e| e.to_string())?;
    unsafe {
        let handle = libraw_wrapper_create();
        if handle.is_null() {
            return Err("Failed to create LibRaw handle".to_string());
        }

        if libraw_wrapper_open(handle, c_filepath.as_ptr()) != 0 {
            libraw_wrapper_destroy(handle);
            return Err(format!("Failed to open file: {}", filepath));
        }

        let id = NEXT_IMAGE_ID.fetch_add(1, Ordering::SeqCst);
        let mut manager = IMAGE_MANAGER.lock().unwrap();
        manager.insert(id, SafeLibRawHandle(handle));
        Ok(id)
    }
}

/// Releases the LibRaw handle associated with the given ID.
pub fn release_raw(id: u64) {
    let mut manager = IMAGE_MANAGER.lock().unwrap();
    if let Some(handle) = manager.remove(&id) {
        unsafe {
            libraw_wrapper_destroy(handle.0);
        }
    }
}

/// Gets the thumbnail for the image associated with the given ID.
pub fn get_thumbnail(id: u64) -> Result<Vec<u8>, String> {
    let manager = IMAGE_MANAGER.lock().unwrap();
    let handle = manager
        .get(&id)
        .ok_or_else(|| "Invalid image ID".to_string())?;

    unsafe {
        // `buf` must be `*const c_char` to match the C++ `const char**` signature.
        // `c_char` is an alias for `i8` on most platforms.
        let mut buf: *const c_char = ptr::null();
        let mut len: c_int = 0;

        // The `&mut buf` is coerced to `*mut *const c_char` for the FFI call.
        if libraw_wrapper_get_thumbnail(handle.0, &mut buf, &mut len) != 0 {
            return Err("Failed to get thumbnail".to_string());
        }

        if buf.is_null() || len <= 0 {
            return Err("No thumbnail data available".to_string());
        }

        // We cast the pointer to `*const u8` to create a byte slice, which is safe.
        let slice = slice::from_raw_parts(buf as *const u8, len as usize);
        Ok(slice.to_vec())
    }
}

/// Gets the metadata for the image associated with the given ID.
pub fn get_metadata(id: u64) -> Result<HashMap<String, String>, String> {
    let manager = IMAGE_MANAGER.lock().unwrap();
    let handle = manager
        .get(&id)
        .ok_or_else(|| "Invalid image ID".to_string())?;

    unsafe {
        let meta_struct: LibRawMetadata = libraw_wrapper_get_metadata(handle.0);
        let mut meta_map = HashMap::new();

        if !meta_struct.make.is_null() {
            meta_map.insert("make".to_string(), CStr::from_ptr(meta_struct.make).to_string_lossy().into_owned());
        }
        if !meta_struct.model.is_null() {
            meta_map.insert("model".to_string(), CStr::from_ptr(meta_struct.model).to_string_lossy().into_owned());
        }
        meta_map.insert("iso".to_string(), meta_struct.iso.to_string());
        meta_map.insert("shutter".to_string(), meta_struct.shutter.to_string());
        meta_map.insert("aperture".to_string(), meta_struct.aperture.to_string());

        Ok(meta_map)
    }
}